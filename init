#!/usr/bin/ash
udevd_running=0
mount_handler=default_mount_handler
init=/sbin/init
rd_logmask=0
. /init_functions
msg "Begining boot process"
mount_setup

# parse the kernel command line
msg "Parsing kernel parameters"
parse_cmdline </proc/cmdline

[ ! -n ${nostderr} ] || exec 2> /dev/null
[ ! -n ${nostdout} ] || exec > /dev/null

for d in ${disablehooks//,/ }; do
    [ -e "/hooks/$d" ] && chmod 644 "/hooks/$d"
done
msg "Configuring"
. /config
msg "Running early hooks"
run_hookfunctions 'run_earlyhook' 'early hook' $EARLYHOOKS

if [ -n "$earlymodules$MODULES" ]; then
    msg "Enabling module for $MODULES"
    modprobe -qab ${earlymodules//,/ } $MODULES
fi
msg "Runningn hooks"
run_hookfunctions 'run_hook' 'hook' $HOOKS

# honor the old behavior of break=y as a synonym for break=premount
if [ "${break}" = "y" ] || [ "${break}" = "premount" ]; then
    warn ":: Pre-mount break requested, type 'exit' to resume operation"
    launch_interactive_shell
fi
#live rootfs detection
if [ -n "$boot"  ]
    then
    list=$(ls /sys/class/block/ | grep -v loop | grep -v ram | grep -v nbd | sed "s|^|/dev/|g")
    for part in $list
    do
        debug "Looking for $part"
        if is_file_avaiable "$part" "$boot/filesystem.squashfs"
        then
           export root=$part
        fi
    done
fi
#non-live detection
debug "Looking for $root"
rootdev=$(resolve_device "$root") && root=$rootdev
unset rootdev
debug "Detected root device: $root"
msg "Running fsck for $root"
fsck_root

# Mount root at /new_root
debug "Mounting $root => /new_root"
"$mount_handler" /new_root
msg "Running late hook"
run_hookfunctions 'run_latehook' 'late hook' $LATEHOOKS
msg "Runningn cleanup hook"
run_hookfunctions 'run_cleanuphook' 'cleanup hook' $CLEANUPHOOKS
#live-boot feature
if [ -n "$boot"  ]
then
    mkdir -p /donkey/a # upper
    mkdir -p /donkey/b # workdir
    mkdir -p /live_root/
    mkdir -p /source/ # lower
    mount /new_root/$boot/filesystem.squashfs /source/ 2> /dev/null
    if [ "$overlay" == "disable" ]
    then
        warn "Overlayfs disabled!"
        mount -t tmpfs -o size=100% none /live_root
        msg "Copying rootfs files => /live_root"
        cp -vprf /source/* /live_root/
    else
        mount -t overlay -o lowerdir=/source/,upperdir=/donkey/a/,workdir=/donkey/b overlay /live_root
        mount -t tmpfs -o size=100% none /donkey/a
        mount -t tmpfs -o size=100% none /donkey/b
    fi
    mount --bind /live_root /new_root/
    mkdir /new_root/cdrom/ 2> /dev/null
    mkdir /new_root/source/ 2> /dev/null
    mount $root /new_root/cdrom/ 2> /dev/null
    mount /new_root/cdrom/$boot/filesystem.squashfs /new_root/source/ 2> /dev/null
fi

if [ "$(stat -c %D /)" = "$(stat -c %D /new_root)" ]; then
    # Nothing got mounted on /new_root. This is the end, we don't know what to do anymore
    # We fall back into a shell, but the shell has now PID 1
    # This way, manual recovery is still possible.
    err "Failed to mount the real root device."
    warn "Bailing out, you are on your own. Good luck."
    warn
    launch_interactive_shell --exec
elif [ ! -x "/new_root${init}" ]; then
    # Successfully mounted /new_root, but ${init} is missing
    # The same logic as above applies
    err "Root device mounted successfully, but ${init} does not exist."
    warn "Bailing out, you are on your own. Good luck."
    warn
    launch_interactive_shell --exec
fi


# this should always be the last thing we do before the switch_root.
if [ -f /new_root/etc/initrd.local ]; then
    msg "Running local initrd scripts"
    . /new_root/etc/initrd.local || true
fi

if [ -f /new_root/etc/os-release ]; then
    msg "Wellcome to $(cat /new_root/etc/os-release | grep '^NAME=' | head -n 1 | sed 's/^.*=//g')"
else
    msg "Wellcome to GNU/Linux..."
fi

if [ "${break}" = "postmount" ]; then
    warn ":: Post-mount break requested, type 'exit' to resume operation"
    launch_interactive_shell
fi

exec env -i \
    "TERM=$TERM" \
    /usr/bin/switch_root /new_root $init "$@" || launch_interactive_shell

# vim: set ft=sh ts=4 sw=4 et:

